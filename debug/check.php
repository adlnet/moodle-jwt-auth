<?php

putenv("MOODLE_JWT_EDIPI_PROPERTY=");
putenv("MOODLE_JWT_USE_EDIPI=");
putenv("MOODLE_JWT_USERNAME_PROPERTY=preferred_username");
putenv("MOODLE_JWT_CHECK_ISSUER=");
putenv("MOODLE_JWT_ISSUER=");
putenv("MOODLE_JWT_CHECK_CLIENT=");
putenv("MOODLE_JWT_CLIENT_ID=");
putenv("MOODLE_JWT_ASSIGN_RANDOM_PASSWORD=true");
putenv("MOODLE_JWT_REQUIRED_ROLE=");

/**
 * Dummy JWT with simple values
 * Check with https://jwt.io/
 * 
 * {
		"alg": "HS256",
		"typ": "JWT"
	}
	{
		"sub": "1234567890",
		"name": "John Doe",
		"iat": 1516239022,
		"preferred_username": "some-user",
		"email": "some-email@gmail.com"
	}
	HMACSHA256(
		base64UrlEncode(header) + "." +
		base64UrlEncode(payload),
		your-256-bit-secret	
	)
 */
$jwt = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJwcmVmZXJyZWRfdXNlcm5hbWUiOiJzb21lLXVzZXIiLCJlbWFpbCI6InNvbWUtZW1haWxAZ21haWwuY29tIn0.Y5jR_DU6RmjyRXfi42hdClIRj3FpvlTimLvYaTCQCQg";

function doesPayloadSatisfyRoleRequirement($payload) {
	
    $roleField = getenv('MOODLE_JWT_ROLE_FIELD');      
    $requiredRole = getenv('MOODLE_JWT_REQUIRED_ROLE');
    
    if (empty($roleField) || empty($requiredRole)) {
        return true;
    }

    if (isset($payload->$roleField) && is_array($payload->$roleField)) {
        return in_array($requiredRole, $payload->$roleField);
    }

    // Return false if the field is not present or the role is not found
    return false;
}

$payloadWithRole = (object)[
    'roles' => ['admin', 'editor', 'user']
];

echo "EXPECTING SUCCESS ...";
echo true == doesPayloadSatisfyRoleRequirement($payloadWithRole);
echo "\n";

echo "EXPECTING FAILURE ...";
putenv("MOODLE_JWT_ROLE_FIELD=non-existent-property");
putenv("MOODLE_JWT_REQUIRED_ROLE=admin");
echo false == doesPayloadSatisfyRoleRequirement($payloadWithRole);
echo "\n";

echo "EXPECTING FAILURE ...";
putenv("MOODLE_JWT_ROLE_FIELD=roles");
putenv("MOODLE_JWT_REQUIRED_ROLE=bad-role-which-does-not-exist");
echo false == doesPayloadSatisfyRoleRequirement($payloadWithRole);
echo "\n";

echo "EXPECTING SUCCESS ...";
putenv("MOODLE_JWT_REQUIRED_ROLE=admin");
echo true == doesPayloadSatisfyRoleRequirement($payloadWithRole);
echo "\n";

 function parse_jwt_component($authtokenRaw) {
 	$authtoken = trim(substr($authtokenRaw, 7));
    $token_parts = explode('.', $authtoken);

    $headerEncoded = $token_parts[0];
    $payloadEncoded = $token_parts[1];
    $signatureEncoded = $token_parts[2];
    
    print_r($headerEncoded);
    print_r($payloadEncoded);
    print_r($signatureEncoded);
    
    $decodedStr = decode_base_64($payloadEncoded);
    $jsonObj = json_decode($decodedStr);

    return $jsonObj;
}

function decode_base_64($encodedStr) {
	
	print_r("Encoded Str:");
	print_r($encodedStr == null);
	
    $a = str_replace('-','+', $encodedStr);
    $b = str_replace('_', '/', $a);

    return base64_decode($b);
}

function attempt_cert_check($payload) {
	/**
	 * We allow the environment to specify whether to perform an issuer check.
	 * 
	 * For some environments, this will be necessary, but for ADL's P1 deployment
	 * this doesn't add any extra security.
	 */
	if (has_env_bool("MOODLE_JWT_CHECK_ISSUER")) {
	
	    $issuer = $payload->iss;
	    $issuerExpected = getenv("MOODLE_JWT_ISSUER");
	
	    if ($issuer != $issuerExpected)
	        return;
	}
	
	/**
	 * Similarly for the token's client value.
	 * 
	 * For Client, this is a bit less obvious as these can be auto-generated by the
	 * deployment environment and should be provided by the Ops / Hosting team.
	 */
	if (has_env_bool("MOODLE_JWT_CHECK_CLIENT")) {
	
	    $client = $payload->azp;
	    $clientExpected = getenv("MOODLE_JWT_CLIENT_ID");
	
	    if ($client != $clientExpected)
	        return;
	}
	
	//$userExists = $DB->record_exists('user', ["email" => $payload->email]);
	
	//if (!$userExists) {
	
	    $username = get_expected_username($payload);
	    $password = null;
	
	    /**
	     * As of Moodle 4.3, created user passwords can no longer be null.
	     * 
	     * Since this auth method does not allow manual logins anyway, the
	     * approach will be to simply create a pseudo-randomized password
	     * for this account, which will be blocked from manual entry anyway.
	     */
	    if (has_env_bool("MOODLE_JWT_ASSIGN_RANDOM_PASSWORD")) {
	
	        /**
	         * The "salt" here will simply be a character block to satisfy password reqs.
	         * 
	         * There are several fairly random properties to choose from, but we will leave
	         * the specification to the configuration folks.  If not specified, then we will
	         * use JWT-standard properties in their place.
	         */
	        $requirementSalt = "aA_12345678";
	
	        $envPropertyFirst = getenv("MOODLE_JWT_ASSIGN_RANDOM_PASSWORD_PROPERTY_FIRST");
	        $envPropertySecond = getenv("MOODLE_JWT_ASSIGN_RANDOM_PASSWORD_PROPERTY_SECOND");
	
	        $firstChunk = $payload->sub;
	        $secondChunk = $payload->iss;
	
	        if ($envPropertyFirst != false) {
	            if (property_exists($payload, $envPropertyFirst)) {
	                $firstChunk = $payload->$envPropertyFirst;
	            }
	        }
	
	        if ($envPropertySecond != false) {
	            if (property_exists($payload, $envPropertySecond)) {
	                $secondChunk = $payload->$envPropertySecond;
	            }
	        }
	
	
	        $password = time() . $firstChunk . $secondChunk . $requirementSalt;
	    }
	
	    $user = create_user_record($username, $password, "jwt", $payload);
	
	    $user->email = $payload->email;
	    $user->firstname = $payload->given_name;
	    $user->lastname = $payload->family_name;
	    $user->mnethostid = $CFG->mnet_localhost_id;
	
	    $user->confirmed = true;
	    $user->policyagreed = true;
	
	    // $DB->update_record("user", $user);
	// }
	// else {
	//     $existingUser = $DB->get_record("user", ["email" => $payload->email]);
	//     $expectedUsername = $this->get_expected_username($payload);
	
	//     if ($existingUser->username != $expectedUsername) {
	//         $existingUser->username = $expectedUsername;
	
	//         $DB->update_record("user", $existingUser);
	//     }
	// }
	
	return $user;
}

function create_user_record($username, $password, $auth, $payload) {
	return (object) array(
		'username' => 'some-username', 
		'password' => null, 
	    'email' => $payload->email,
	    'firstname' => $payload->given_name,
	    'lastname' => $payload->family_name,
	    'mnethostid' => $CFG->mnet_localhost_id, 
	    'confirmed' => true,
	    'policyagreed' => true,
	);
}

function has_env_bool($variableName) {
    $value = getenv($variableName);
    $exists = $value != false;

    return $exists && (strcasecmp($value, "true") == 0);
}

function get_expected_username($cert) {

    $envEDIPIProperty = getenv("MOODLE_JWT_EDIPI_PROPERTY");

    $useEDIPI = has_env_bool("MOODLE_JWT_USE_EDIPI");
    $configuredForEDIPI =  $envEDIPIProperty != false;

    if ($useEDIPI && $configuredForEDIPI) {
        $edipiNumber = get_edipi_number($cert, $envEDIPIProperty);
        $foundEDIPI = !is_null($edipiNumber);

        if ($foundEDIPI) {
            return $edipiNumber;
        }
    }
    
    $envCustomProperty = getenv("MOODLE_JWT_USERNAME_PROPERTY");
    $useCustomProperty = $envCustomProperty != false;
    
    if ($useCustomProperty) {
    	
    	$hasCustomProperty = property_exists($cert, $envCustomProperty);
	    if ($hasCustomProperty) {
	        return $cert->$envCustomProperty;
	    }
    }


    return get_default_username($cert);
}

function get_default_username($cert) {
    return $cert->preferred_username;
}

function get_edipi_number($cert, $edipiProperty) {

    $certHasProperty = property_exists($cert, $edipiProperty);
    if ($certHasProperty == false)
        return null;

    $edipiRaw = $cert->$edipiProperty;
    
    $edipiParsedAsString = is_string($edipiRaw);
    if ($edipiParsedAsString == false)
        return null;

    $edipiParts = explode(".", $edipiRaw);
    $edipiLastPart = end($edipiParts);

    $edipiNumber = preg_replace("/[^0-9]/", "", $edipiLastPart);
    $hasCorrectLength = strlen($edipiNumber) == 10;

    if ($hasCorrectLength) {
        return $edipiNumber;
    }

    return null;
}

$cert = parse_jwt_component($jwt);

print_r($cert);

$user = attempt_cert_check($cert);

print($user->username);
